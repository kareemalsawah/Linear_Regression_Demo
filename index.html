<!DOCTYPE html>
<html>
<head>
  <title>Weight Space Visualization</title>
  <link rel = "stylesheet"
   type = "text/css"
   href = "css/bootstrap.css" />
   <script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>
   <script src="helper.js"></script>
</head>
<body>
  <header>Linear Regression</header>
  <div class="container">
    <div class="row text-center">
        <p class="text-center" style="color:red;">Note that mobile support hasn't been added, yet</p>
    </div>
    <div class="row">
      <div class="col-lg-2">
      </div>
      <div class="col-lg-8">
        This is the simplest kind of regression. Simply put, the function that generates the data is linear (actually it is linear in the weights but can be non linear in the inputs, this is discussed in the next algorithm “SVM” as the kernel trick). This means that f(x) is a straight line. Linear regression attempts to find a function h(x) that approximates f(x) given the data generated by f(x) (which could have noise added to it). How can we do that?
      </br>
        First, we need to define an error function that takes in h(x) as an input and returns the error between our approximation and the given data. The most common error functions used are mean-squared-error and mean-absolute-error.
      </br>
        If the input data is $$(x_{1},y_{1}),(x_{2},y_{2}),...,(x_{N},y_{N})$$
        The mean squared error (MSE) = $$\frac{1}{N}\sum {[h(x_{i})−y_{i}]^2}$$
        The mean absolute error (MAE) = $$\frac{1}{N}\sum {\left | h(x_{i})−y_{i} \right |}$$
      </br>
        Now that we have a measure of the error we want to minimize it. To do that we must determine what variables affect the error. Your first guess might be the inputs; however, note that the inputs don’t change while we run the algorithm, the values that change are the parameters in h(x). Since h(x) is linear, h(x) = mx+b, this function changes according to m, and b. We will let  and . Again x doesn’t affect the error here as it is part of the input values which are constant during training.
      </br>
        Using some calculus, we take derivatives and reach the following formulas:
        <img src="imgs/linear_regression_weights.png"></img>
      </br>
        To have a better intuition, let us see what happens with MSE and MAE in weight space. Weight space is a basically the space where the axes are the weights. We will use it to visualize the error function which changes according to w1 (on the y-axis) and w2 (on the x-axis)
        The color at a point determines the error, red is the highest error and blue is the least error.

      </div>
    </div>
    <div class="row">
      <div class="col-lg-12 text-center">
    <canvas class="text-center" id="canvas" width="1000" height="1000"></canvas>
      </div>
    </div>
    <div class="row">
      <div class="col-lg-12 text-center">
        <div class="dropdown">
          <button class="dropbtn">Error function</button>
          <div class="dropdown-content">
            <a href="#" onclick="changeErrorFunction(0);">MSE</a>
            <a href="#" onclick="changeErrorFunction(1);">MAE</a>
          </div>
        </div>
        <a class="btn btn-primary" onclick="findBestLine(3);">Find best line</a>
      </div>
    </div>
    <div class="row" style="margin-top:5vh;">
      <div class="col-lg-2">
      </div>
      <div class="col-lg-8">
        What is the difference between using MAE and MSE?
      </br>
        Without going into the math too much, MAE encourages sparse weights (weights that equal 0 or that are small), while MSE doesn’t.
      </div>
    </div>
</div>
<footer></footer>
</body>
<script src="opencv.js"></script>
<script>
  var canvas = document.getElementById("canvas");
  var heightRatio = 0.5;
  canvas.height = canvas.width*heightRatio;
  var ctx = canvas.getContext("2d");

  var cursor_position = [800,300];
  var seperator_width = 3;
  var cursor_radius = 5;
  var points_arr = [[5,10]];
  var canvas_width_scale = 30;
  var canvas_height_scale = 30;
  var line_params = [1,0];
  var errorImageData = undefined;
  var weight_1_space_scale = 10;
  var weight_2_space_scale = 100;
  var errorFunction = 0;


updateWeightSpace();
drawFrame();

  /*
  Given an array of points, this function will draw them on the canvas
  */
  function drawPoints(points){
    for(var i = 0; i < points.length; i++){
      var point_position = points[i];
      var x = map(point_position[0],0,canvas_width_scale,250,500);
      var y = map(point_position[1],0,canvas_height_scale,250,0);
      drawPoint(x,y,3,"black");
    }
  }

  /*
  Given the line parameters [slope,y-intercept], this function will draw the line on the canvas
  */
  function drawLine(params){
    var slope = -1*params[0];
    var intercept = map(params[1],0,canvas_height_scale,250,0);
    ctx.beginPath();
    ctx.moveTo(0, intercept-slope*250);
    ctx.lineTo(500, intercept+slope*250);
    ctx.strokeStyle = "black";
    ctx.stroke();
    ctx.closePath();
  }

  /*
  This function changes the error function used (MSE or MAE) according to type (0 => MSE, 1 => MAE)
  */
  function changeErrorFunction(type){
    if (type!=errorFunction){
      errorFunction = type;
      updateWeightSpace();
    }
  }

  /*
  Recalculate weight space and save the new image
  */
  function updateWeightSpace(){
    drawHeatMap(3);
    var dst = cv.imread("canvas");
    var crop_rect = new cv.Rect(500, 0, 500, 500);
    var src = dst.roi(crop_rect);
    dst = new cv.Mat();
    var ksize = new cv.Size(11,11);
    cv.GaussianBlur(src, dst, ksize, 0, 0, cv.BORDER_DEFAULT);
    errorImageData = new ImageData(new Uint8ClampedArray(dst.data, dst.cols, dst.rows),500);
  }

  /*
  Calculate the error of a certain point in weight space (params)
  */
  function calculateError(params,points){
    var totalError = 0;
    for(var i = 0; i < points.length; i++){
      var point = points[i];
      var pred = params[0]*point[0]+params[1];
      var target = point[1];
      var error = 0;
      if(errorFunction==0){
        error = Math.abs(pred-target)*Math.abs(pred-target);
      }else{
        error = Math.abs(pred-target);
      }
      totalError += error;
    }
    totalError /= points.length;
    return totalError;
  }


  function drawFrame(){
    drawBorder("black",2);
    drawMiddleSeperator("black",seperator_width);
    drawAxes(250,250,"black",490,490,2);
    drawLine(line_params);
    drawPoints(points_arr);

    ctx.putImageData(errorImageData, 500, 0);
    drawText();
    drawAxes(750,250,"black",490,490,2);
  }
  function drawText(){
    ctx.font = "20px Arial";
    ctx.fillText("w1 :"+Math.floor(line_params[0]*100)/100, 880, 420);
    ctx.fillText("w2 :"+Math.floor(line_params[1]*100)/100, 880, 450);
    ctx.fillText("Error :"+Math.floor(calculateError(line_params,points_arr)*100)/100, 880, 480);
  }


  function drawHeatMap(gridSize){
    var startPos = [500,0];
    var errors = [];
    var minError = 999999;
    var maxError = 0;
    while(startPos[1]<canvas.height){
      if(startPos[0]>=canvas.width){
        startPos[1] += gridSize;
        startPos[0] = 500;
      }else{
        var w1 = map(startPos[0],500,1000,-weight_1_space_scale,weight_1_space_scale);
        var w2 = map(startPos[1],0,500,-weight_2_space_scale,weight_2_space_scale);
        var errorValue = calculateError([w1,w2],points_arr);
        errors.push(errorValue);
        if(errorValue<minError){
          minError = errorValue;
        }
        if (errorValue>maxError){
          maxError = errorValue;
        }
        startPos[0] += gridSize;
      }
    }

    var startPos = [500,0];
    var index = 0;
    while(startPos[1]<canvas.height){
      if(startPos[0]>=canvas.width){
        startPos[1] += gridSize;
        startPos[0] = 500;
      }else{
        //errors[index] = map(errors[index],minError,maxError,0,1);
        errors[index] = customSigmoid(errors[index],minError,maxError);
        ctx.beginPath();
        ctx.fillStyle = heatMapColorforValue(errors[index]);
        ctx.rect(startPos[0],startPos[1],gridSize,gridSize);
        ctx.fill();
        ctx.closePath();
        startPos[0] += gridSize;
        index++;
      }
    }
  }

  function drawBorder(color,width){
    ctx.beginPath();
    ctx.fillStyle = color;
    ctx.rect(0,0,canvas.width,canvas.height);
    ctx.fill();
    ctx.closePath();
    ctx.beginPath();
    ctx.fillStyle = "white";
    ctx.rect(width,width,canvas.width-2*width,canvas.height-2*width);
    ctx.fill();
    ctx.closePath();
  }


  function moveCursor(event){
    if (mouse_is_down){
      var totalOffsetX = 0;
      var totalOffsetY = 0;
      var canvasX = 0;
      var canvasY = 0;
      var currentElement = this;

      do{
          totalOffsetX += currentElement.offsetLeft - currentElement.scrollLeft;
          totalOffsetY += currentElement.offsetTop - currentElement.scrollTop;
      }
      while(currentElement = currentElement.offsetParent)

      canvasX = event.pageX - totalOffsetX;
      canvasY = event.pageY - totalOffsetY;

      var positionInfo = canvas.getBoundingClientRect();
      var height = positionInfo.height;
      var width = positionInfo.width;
      canvasX *= canvas.width/width;
      canvasY *= canvas.height/height;
      if(canvasX>canvas.width/2+seperator_width/2+cursor_radius){
        line_params[0] = map(canvasX,500,1000,-weight_1_space_scale,weight_1_space_scale);
        line_params[1] = map(canvasY,0,500,-weight_2_space_scale,weight_2_space_scale);
        drawFrame();
        drawCursor(canvasX,canvasY);
        cursor_position = [canvasX,canvasY];
      }
    }
}

var mouse_is_down = false;
function handleMouseDown(event){
  mouse_is_down = true;
  var totalOffsetX = 0;
  var totalOffsetY = 0;
  var canvasX = 0;
  var canvasY = 0;
  var currentElement = this;

  do{
      totalOffsetX += currentElement.offsetLeft - currentElement.scrollLeft;
      totalOffsetY += currentElement.offsetTop - currentElement.scrollTop;
  }
  while(currentElement = currentElement.offsetParent)

  canvasX = event.pageX - totalOffsetX;
  canvasY = event.pageY - totalOffsetY;

  var positionInfo = canvas.getBoundingClientRect();
  var height = positionInfo.height;
  var width = positionInfo.width;
  canvasX *= canvas.width/width;
  canvasY *= canvas.height/height;
  if(canvasX>canvas.width/2+seperator_width/2+cursor_radius){
    line_params[0] = map(canvasX,500,1000,-weight_1_space_scale,weight_1_space_scale);
    line_params[1] = map(canvasY,0,500,-weight_2_space_scale,weight_2_space_scale);
    drawFrame();
    drawCursor(canvasX,canvasY);
    cursor_position = [canvasX,canvasY];
  }else{
    var point_position = [0,0];
    point_position[0] = map(canvasX,0,500,-canvas_width_scale,canvas_width_scale);
    point_position[1] = map(canvasY,500,0,-canvas_height_scale,canvas_height_scale);
    points_arr.push(point_position);
    updateWeightSpace();
    drawFrame();
    drawCursor(cursor_position[0],cursor_position[1]);
  }
}
function handleMouseUp(event){
  mouse_is_down = false;
}
canvas.addEventListener("mousedown", handleMouseDown, false);
canvas.addEventListener("mousemove",moveCursor,false);
document.addEventListener("mouseup", handleMouseUp, false);

function drawCursor(x,y){
  drawPoint(x,y,cursor_radius,"black");
}

function drawPoint(x,y,radius,color){
  ctx.beginPath();
  ctx.fillStyle = color;
  ctx.arc(x, y, radius, 0, 2 * Math.PI);
  ctx.fill();
  ctx.closePath();
}

function drawMiddleSeperator(color,width){
  ctx.beginPath();
  ctx.fillStyle = color;
  ctx.rect(canvas.width/2 - width/2,0,width,canvas.height);
  ctx.fill();
  ctx.closePath();
}

function drawAxes(x,y,color,width,height,thickness){
  ctx.beginPath();
  ctx.fillStyle = color;
  ctx.rect(x-width/2,y,width,thickness);
  ctx.fill();
  ctx.closePath();
  ctx.beginPath();
  ctx.fillStyle = color;
  ctx.rect(x,y-height/2,thickness,height);
  ctx.fill();
  ctx.closePath();
}
function printCanvasInfo(){
var positionInfo = canvas.getBoundingClientRect();
var height = positionInfo.height;
var width = positionInfo.width;
console.log({"width":width,"height":height});
}


function findBestLine(gridSize){
  var startPos = [500,0];
  var errors = [];
  var minError = 999999;
  var minErrorParams = [1,0];
  while(startPos[1]<canvas.height){
    if(startPos[0]>=canvas.width){
      startPos[1] += gridSize;
      startPos[0] = 500;
    }else{
      var w1 = map(startPos[0],500,1000,-weight_1_space_scale,weight_1_space_scale);
      var w2 = map(startPos[1],0,500,-weight_2_space_scale,weight_2_space_scale);
      var errorValue = calculateError([w1,w2],points_arr);
      errors.push(errorValue);
      if(errorValue<minError){
        minError = errorValue;
        minErrorParams = [w1,w2];
      }
      startPos[0] += gridSize;
    }
  }
  line_params = minErrorParams;
  cursor_position[0] = map(line_params[0],-weight_1_space_scale,weight_1_space_scale,500,1000);
  cursor_position[1] = map(line_params[1],-weight_2_space_scale,weight_2_space_scale,0,500);
  drawFrame();
  drawCursor(cursor_position[0],cursor_position[1]);
}
</script>
<style>
  #canvas{
    margin-top:4vh;
      width:80%;
  }

  img{
    width:100%;
    margin-top:5vh;
    margin-bottom:5vh;
  }

  header {
  background-color: #666;
  padding: 30px;
  text-align: center;
  font-size: 35px;
  color: white;
  margin-bottom:10vh;
  }

  footer {
  background-color: #777;
  padding: 5vh;
  text-align: center;
  color: white;
  margin-top:10vh;
  }

  .dropbtn {
  background-color: #4C61FF;
  color: white;
  padding: 16px;
  font-size: 16px;
  border: none;
}

.dropdown {
  position: relative;
  display: inline-block;
}

.dropdown-content {
  display: none;
  position: absolute;
  background-color: #f1f1f1;
  min-width: 160px;
  box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
  z-index: 1;
}

.dropdown-content a {
  color: black;
  padding: 12px 16px;
  text-decoration: none;
  display: block;
}

.dropdown-content a:hover {background-color: #ddd;}

.dropdown:hover .dropdown-content {display: block;}

.dropdown:hover .dropbtn {background-color: #223CFE;}
</style>
</html>
